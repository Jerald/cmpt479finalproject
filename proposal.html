<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-alpha/dist/katex.min.css" integrity="sha384-BTL0nVi8DnMrNdMQZG1Ww6yasK9ZGnUxL1ZWukXQ7fygA1py52yPp9W4wrR00VML" crossorigin="anonymous">
        <style>
/*--------------------------------------------------------------------------------------------- * Copyright (c) Microsoft Corporation. All rights reserved. * Licensed under the MIT License. See License.txt in the project root for license information. *--------------------------------------------------------------------------------------------*/ body { font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback"; font-size: 14px; padding: 0 26px; line-height: 22px; word-wrap: break-word; } #code-csp-warning { position: fixed; top: 0; right: 0; color: white; margin: 16px; text-align: center; font-size: 12px; font-family: sans-serif; background-color:#444444; cursor: pointer; padding: 6px; box-shadow: 1px 1px 1px rgba(0,0,0,.25); } #code-csp-warning:hover { text-decoration: none; background-color:#007acc; box-shadow: 2px 2px 2px rgba(0,0,0,.25); } body.scrollBeyondLastLine { margin-bottom: calc(100vh - 22px); } body.showEditorSelection .code-line { position: relative; } body.showEditorSelection .code-active-line:before, body.showEditorSelection .code-line:hover:before { content: ""; display: block; position: absolute; top: 0; left: -12px; height: 100%; } body.showEditorSelection li.code-active-line:before, body.showEditorSelection li.code-line:hover:before { left: -30px; } .vscode-light.showEditorSelection .code-active-line:before { border-left: 3px solid rgba(0, 0, 0, 0.15); } .vscode-light.showEditorSelection .code-line:hover:before { border-left: 3px solid rgba(0, 0, 0, 0.40); } .vscode-light.showEditorSelection .code-line .code-line:hover:before { border-left: none; } .vscode-dark.showEditorSelection .code-active-line:before { border-left: 3px solid rgba(255, 255, 255, 0.4); } .vscode-dark.showEditorSelection .code-line:hover:before { border-left: 3px solid rgba(255, 255, 255, 0.60); } .vscode-dark.showEditorSelection .code-line .code-line:hover:before { border-left: none; } .vscode-high-contrast.showEditorSelection .code-active-line:before { border-left: 3px solid rgba(255, 160, 0, 0.7); } .vscode-high-contrast.showEditorSelection .code-line:hover:before { border-left: 3px solid rgba(255, 160, 0, 1); } .vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before { border-left: none; } img { max-width: 100%; max-height: 100%; } a { text-decoration: none; } a:hover { text-decoration: underline; } a:focus, input:focus, select:focus, textarea:focus { outline: 1px solid -webkit-focus-ring-color; outline-offset: -1px; } hr { border: 0; height: 2px; border-bottom: 2px solid; } h1 { padding-bottom: 0.3em; line-height: 1.2; border-bottom-width: 1px; border-bottom-style: solid; } h1, h2, h3 { font-weight: normal; } h1 code, h2 code, h3 code, h4 code, h5 code, h6 code { font-size: inherit; line-height: auto; } table { border-collapse: collapse; } table > thead > tr > th { text-align: left; border-bottom: 1px solid; } table > thead > tr > th, table > thead > tr > td, table > tbody > tr > th, table > tbody > tr > td { padding: 5px 10px; } table > tbody > tr + tr > td { border-top: 1px solid; } blockquote { margin: 0 7px 0 5px; padding: 0 16px 0 10px; border-left-width: 5px; border-left-style: solid; } code { font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback"; font-size: 14px; line-height: 19px; } body.wordWrap pre { white-space: pre-wrap; } .mac code { font-size: 12px; line-height: 18px; } pre:not(.hljs), pre.hljs code > div { padding: 16px; border-radius: 3px; overflow: auto; } /** Theming */ pre code { color: var(--vscode-editor-foreground); } .vscode-light pre:not(.hljs), .vscode-light code > div { background-color: rgba(220, 220, 220, 0.4); } .vscode-dark pre:not(.hljs), .vscode-dark code > div { background-color: rgba(10, 10, 10, 0.4); } .vscode-high-contrast pre:not(.hljs), .vscode-high-contrast code > div { background-color: rgb(0, 0, 0); } .vscode-high-contrast h1 { border-color: rgb(0, 0, 0); } .vscode-light table > thead > tr > th { border-color: rgba(0, 0, 0, 0.69); } .vscode-dark table > thead > tr > th { border-color: rgba(255, 255, 255, 0.69); } .vscode-light h1, .vscode-light hr, .vscode-light table > tbody > tr + tr > td { border-color: rgba(0, 0, 0, 0.18); } .vscode-dark h1, .vscode-dark hr, .vscode-dark table > tbody > tr + tr > td { border-color: rgba(255, 255, 255, 0.18); } 
</style>
<style>
/* Tomorrow Theme */ /* http://jmblog.github.com/color-themes-for-google-code-highlightjs */ /* Original theme - https://github.com/chriskempson/tomorrow-theme */ /* Tomorrow Comment */ .hljs-comment, .hljs-quote { color: #8e908c; } /* Tomorrow Red */ .hljs-variable, .hljs-template-variable, .hljs-tag, .hljs-name, .hljs-selector-id, .hljs-selector-class, .hljs-regexp, .hljs-deletion { color: #c82829; } /* Tomorrow Orange */ .hljs-number, .hljs-built_in, .hljs-builtin-name, .hljs-literal, .hljs-type, .hljs-params, .hljs-meta, .hljs-link { color: #f5871f; } /* Tomorrow Yellow */ .hljs-attribute { color: #eab700; } /* Tomorrow Green */ .hljs-string, .hljs-symbol, .hljs-bullet, .hljs-addition { color: #718c00; } /* Tomorrow Blue */ .hljs-title, .hljs-section { color: #4271ae; } /* Tomorrow Purple */ .hljs-keyword, .hljs-selector-tag { color: #8959a8; } .hljs { display: block; overflow-x: auto; color: #4d4d4c; padding: 0.5em; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: bold; }
</style>
<style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'HelveticaNeue-Light', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
    </head>
    <body>
        <h1 id="cmpt-479-team-symbad">CMPT 479: Team Symbad</h1>
<h2 id="team-members">Team Members</h2>
<p>Cole Greer</p>
<p>Oscar Smith-Sieger</p>
<h2 id="the-problem">The Problem</h2>
<p>Why in 2018 is it still a job to spend 100 hours running into a wall at every possible angle? We really don't know, but we think it's a bit of a problem. Our idea is to utilize automated software analysis techniques to attempt to find and diagnose problematic program states in highly state-based programs. In our case, this is games.</p>
<h2 id="existing-work">Existing Work</h2>
<p>The game development industry is generally way behind the times when it comes to modern software development techniques. In searching, we were unable to find any comprehensive test systems in use for game development. In general, all that is done by most existing systems is simple static analysis culminating in little more than linting.</p>
<p>An example of a tool ahead of the times (but still from 2012!) is &quot;WallMonster&quot;<a href="http://the-witness.net/news/2012/12/mapping-the-islands-walkable-surfaces/">^1</a> used in the development of <em>The Witness</em>. This tool is still fundamentally rudimentary and very case-specific. It is quite hard to extend the actual tool (though not the process) to other games or engines.</p>
<h2 id="our-idea">Our Idea</h2>
<p>Our attempt to solve this problem is based around performing static analysis, in a similar form to symbolic execution, to reason about the state of individual objects within the program.</p>
<p>The concept is based around identifying individual state-based objects within the program, such as the player, enemies, etc. These objects are considered state-based since the game as a whole operates on a tick-based system, providing a sort of &quot;time&quot; which controls all objects.</p>
<p>Once identified, our model is to determine whatever variables, in a symbolic fashion, can affect the state of the object in a given tick. This would form a &quot;function&quot; of sorts which takes these variables as input, and provides the updated object state as output.</p>
<p>By identifying all these factors which can change an object, we can construct a dependency graph of information between different objects in a given tick. Then we can take this information and determine the domain of the inputs for these objects. From there, we can, by simple union of all these domains, determine the set of all inputs to which the program responds.</p>
<p>Fundamentally, the model of tracking the program state via the symbolic object state is the most useful part of the project. This is because that information can then be extrapolated to provide the basis of many other analysis tools.</p>
<h2 id="the-tools-and-platform">The Tools and Platform</h2>
<p>We plan to attempt to implement this concept for the Unity game engine. This is due to the fact it is free, and well-used within the industry. Unity primarily uses C# for its programming, which means we're unable to use LLVM for our analysis. In its stead, we found a tool called <a href="https://www.mono-project.com/docs/tools+libraries/libraries/Mono.Cecil/">Mono.Cecil</a> which provides at least some of the features of LLVM. It will allow us to investigate and modify the compiled library files used in C# and the .NET platform.</p>
<h2 id="evaluation">Evaluation</h2>
<p>To determine the effectiveness of our system we plan to use a very simple metric: does it produce useful output. That may seem simplistic, but fundamentally the core goal of ours is to create the base model which can later be extended to provide more useful core analysis.</p>
<h2 id="stretch-goals">Stretch Goals</h2>
<p>If we're able to complete the core system to produce the model, we have a number of extensions we've thought of which would use the information to provide actual benefit.</p>
<p>The first of these would be a module allowing a user to place a constraint on the domain of a given variable within an object. From there, the change would propogate through the model producing a new set of possible inputs. The compliment of this new set taken in the universe of the set of all inputs the program responds to (aka, the un-constrained inputs) would be the set of inputs producing the unintended outcome. A developer can then use this information to ensure the condition is being enforced, through the inputs maintaining their constraint.</p>
<p>Another concept would be to use the dependency information to discover the data dependencies and non-dependencies through the program. This would provide a basis for a system to identify parallelizable sections of the program.</p>

    </body>
    </html>