% TEMPLATE for Usenix papers, specifically to meet requirements of
%  USENIX '05
% originally a template for producing IEEE-format articles using LaTeX.
%   written by Matthew Ward, CS Department, Worcester Polytechnic Institute.
% adapted by David Beazley for his excellent SWIG paper in Proceedings,
%   Tcl 96
% turned into a smartass generic template by De Clarke, with thanks to
%   both the above pioneers
% use at your own risk.  Complaints to /dev/null.
% make it two column with no page numbering, default is 10 point

% Munged by Fred Douglis <douglis@research.att.com> 10/97 to separate
% the .sty file from the LaTeX source template, so that people can
% more easily include the .sty file into an existing document.  Also
% changed to more closely follow the style guidelines as represented
% by the Word sample file.

% Note that since 2010, USENIX does not require endnotes. If you want
% foot of page notes, don't include the endnotes package in the 
% usepackage command, below.

% This version uses the latex2e styles, not the very ancient 2.09 stuff.

% Updated July 2018: Text block size changed from 6.5" to 7"

\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{finalReport_style,epsfig,endnotes}
\begin{document}

%don't want date printed
\date{}

%make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf BAD: Automated Assertion Verification and Generation for Game Testing}

%for single author (just remove % characters)
\author{
{\rm Oscar Smith-Sieger}\\
Simon Fraser University
\and
{\rm Cole Greer}\\
Simon Fraser University
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author

\maketitle

% Use the following at camera-ready time to suppress page numbers.
% Comment it out when you first submit the paper for review.
\thispagestyle{empty}


\subsection*{Abstract}
Your Abstract Text Goes Here.  Just a few facts.
Whet our appetites.

\section{Introduction}

%- What we're doing
%- How we're doing it
%- What we've done

Game development is one of the fastest growing software development fields. In the modern age where the industry is quickly embracing automated testing to help catch errors, game development hasn't kept up. In an attempt to remedy this, we introduce BAD: a three-phase system to automatically verify and generate program assertions to help validate correct game behaviour.

BAD is based around creating a tick-agnostic model of game object interactions to attempt to summarize relevant game object behaviour. Our system does this over three phases:

\begin{enumerate}
    \item{\textbf{Model Generation:}} by analyzing the code of a game we abstract away game objects to simply their name, modifiable fields, and the ways they interact with other objects. 
    \item {\textbf{Assertion Verification:}} using the model generated in phase 1 along with assertions provided to the system, we apply a type of inductive proof to see if the assertions are upheld, or how they could be invalidated.
    \item{\textbf{Assertion Generation:}} by taking in information about the layout of a game (say, level information) and combining it with the generated model, the system will look for types of idiomatic mistakes and symptomatic designs which should be checked for correctness.
\end{enumerate}

We've created a proof-of-concept implementation of BAD in C\#, targeting the Unity game engine. We use .NET Core as the runtime for the system, so it can be used cross-platform. Currently the system performs effective generation of the model and basic analysis of assertions. The assertion generation phase of the system is still being designed, but we have a solid design plan laid out for when the time comes.

\section{Background}

The game development industry has yet to fully embrace automated testing and to this day, game testing remains a very hands-on labour intensive process. Manual testing of video games is slow, expensive, and results in poor coverage of the total game state space. As an extreme, yet real world, example, there is still a job in which someone is paid to spend hundreds of hours bumping into walls to test collision. The current state of video game testing is ripe for improvements. Automation would bring much needed efficiency to the industry.

%TODO
A noteworthy example of automated game testing is the \textit{Walk Monster}~\cite{WalkMonster} exploration tool which was written for \textit{The Witness}. 

Some embedded literal typset code might 
look like the following :

{\tt \small
\begin{verbatim}
int wrap_fact(ClientData clientData,
              Tcl_Interp *interp,
              int argc, char *argv[]) {
    int result;
    int arg0;
    if (argc != 2) {
        interp->result = "wrong # args";
        return TCL_ERROR;
    }
    arg0 = atoi(argv[1]);
    result = fact(arg0);
    sprintf(interp->result,"%d",result);
    return TCL_OK;
}
\end{verbatim}
}

Now we're going to cite somebody.  Watch for the cite tag.
Here it comes~\cite{Chaum1981,Diffie1976}.  The tilde character (\~{})
in the source means a non-breaking space.  This way, your reference will
always be attached to the word that preceded it, instead of going to the
next line.

\section{Approach}

BAD has the three phases of \textbf{Model Generation}, \textbf{Assertion Validation}, and \textbf{Assertion Generation}. Together these form of the core of the how the BAD system accomplishes its goal. 

\subsection{Phase One: Model Generation}

Our model is a \textbf{tick-agnostic} abstraction of game object interaction representing overall game behaviour. \textbf{Tick-agnostic} is referring to how we model the state of game objects at an arbitrary point in time. By typical design, games have at their core a main loop running every frame (or \textbf{tick}) where game object code is ran. Standard program analysis tools tend to look at the paths a program can take, a process not well suited to dealing with the heavily loop-based design of games. Our model creates a generic snapshot of how game objects can interact at any point, letting us avoid the key issue.

The model is represented by a dirgraph where nodes represent game objects and edges represent their interaction, annotated with what the interaction is. Stored within a node we have an ID (often simply the class name) as well as references to the incoming and outgoing edges. The specific way we represent interactions between nodes is by the operations one node may apply to another. These edges provide an encoding of how, what, and by who parts of a given game object can ever be affected. 

At a high level, you can think of the graph as representing the state of the game at some arbitrary tick $k$, as opposed to any concrete point in the execution. The nodes can then be thought of as functions, taking all the fields modified by their edges as input, and producing the state at tick $k + 1$ as an output. So by using this, we can apply some, or all, of the possible modifications to a node and then examine generically what would happen as a result. This is the key distinction of our model versus other typical analysis systems.

To create the actual model itself in our reference implementation, we take in game source code compiled to a CIL\endnote{CIL is the Common Intermedeary Language. It's the low-level pseudo-assembly language ran on the .NET platform.} binary, known as an assembly. We utilize the \textit{Mono.Cecil}~\cite{Mono.Cecil} library to load and read the raw CIL. From there we identify game objects (in this case classes) to create nodes of, then search for and identify idioms within the code which correspond to affecting another game object. The actual operations applied by the effect are then encoded onto the edge between the nodes and its annotation. 

\subsection{Phase Two: Assertion Verification}

Our assertion verification system is moddeled as an inductive proof,


It can get tricky typesetting Tcl and C code in LaTeX because they share
a lot of mystical feelings about certain magic characters.  You
will have to do a lot of escaping to typeset curly braces and percent
signs, for example, like this:
``The {\tt \%module} directive
sets the name of the initialization function.  This is optional, but is
recommended if building a Tcl 7.5 module.
Everything inside the {\tt \%\{, \%\}}
block is copied directly into the output. allowing the inclusion of
header files and additional C code." \\

Sometimes you want to really call attention to a piece of text.  You
can center it in the column like this:
\begin{center}
{\tt \_1008e614\_Vector\_p}
\end{center}
and people will really notice it.\\

\noindent
The noindent at the start of this paragraph makes it clear that it's
a continuation of the preceding text, not a new para in its own right.


Now this is an ingenious way to get a forced space.
{\tt Real~$*$} and {\tt double~$*$} are equivalent. 

Now here is another way to call attention to a line of code, but instead
of centering it, we noindent and bold it.\\

\noindent
{\bf \tt size\_t : fread ptr size nobj stream } \\

And here we have made an indented para like a definition tag (dt)
in HTML.  You don't need a surrounding list macro pair.
\begin{itemize}
\item[]  {\tt fread} reads from {\tt stream} into the array {\tt ptr} at
most {\tt nobj} objects of size {\tt size}.   {\tt fread} returns
the number of objects read. 
\end{itemize}
This concludes the definitions tag.

\subsection{Phase Three: Assertion Generation}

You have to run {\tt latex} once to prepare your references for
munging.  Then run {\tt bibtex} to build your bibliography metadata.
Then run {\tt latex} twice to ensure all references have been resolved.
If your source file is called {\tt usenixTemplate.tex} and your {\tt
  bibtex} file is called {\tt usenixTemplate.bib}, here's what you do:
{\tt \small
\begin{verbatim}
latex usenixTemplate
bibtex usenixTemplate
latex usenixTemplate
latex usenixTemplate
\end{verbatim}
}


\subsection{Last SubSection}

Well, it's getting boring isn't it.  This is the last subsection
before we wrap it up.

\section{Evaluation \& Observations}CIL2binary

\section{Related Work}

\section{Future Work}

\section{Conclusion}

A polite author always includes acknowledgments.  Thank everyone,
especially those who funded the work. 

\section{Availability}

It's great when this section says that MyWonderfulApp is free software, 
available via anonymous FTP from

\begin{center}
{\tt ftp.site.dom/pub/myname/Wonderful}\\
\end{center}

Also, it's even greater when you can write that information is also 
available on the Wonderful homepage at 

\begin{center}
{\tt http://www.site.dom/\~{}myname/SWIG}
\end{center}

Now we get serious and fill in those references.  Remember you will
have to run latex twice on the document in order to resolve those
cite tags you met earlier.  This is where they get resolved.
We've preserved some real ones in addition to the template-speak.
After the bibliography you are DONE.

\begin{thebibliography}{9}
    \bibitem{WalkMonster}
    Casey Muratori\\
    \texttt{https://caseymuratori.com/blog\_0005}

    \bibitem{Mono.Cecil}
    Jb Evain\\
    Mono Project\\
    \texttt{https://www.mono-project.com/docs/tools+libraries/libraries/Mono.Cecil/}
\end{thebibliography}

% \begin{bibliography}
% \bibitem[Casey Muratori]{WalkMonster}
% Casey Muratori
% \textit{\LaTeX{}: a document preparation system}. 
% Addison-Wesley, Reading, Massachusetts, 1993.
% \end{bibliography}


%{\normalsize \bibliographystyle{acm}
%\bibliography{./finalReport}}



\theendnotes



\end{document}







